
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>动手创建 NSObject - Yong的Blog</title>
  <meta name="author" content="Yong Li">

  
  <meta name="description" content="本文译自这里，转载请注明！ 在 Cocoa 编程时创建和使用的（几乎）所有类都是以 NSObject 为根基，但它背后都做了什么、是怎么做的呢？今天，我将从零开始创建 NSObject。 根类(root class)的组成 准确地说，根类到底做了什么？以 Objective-C 自身的术语描述， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://liyong03.github.io/blog/2014/03/09/lets-build-nsobject">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Yong的Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-47130724-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Yong的Blog</a></h1>
  
    <h2>技术生活随想</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:liyong03.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">动手创建 NSObject</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-03-09T00:16:54+08:00" pubdate data-updated="true">Mar 9<span>th</span>, 2014</time>
        
           | <a href="#disqus_thread"
             data-disqus-identifier="http://liyong03.github.io">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p>本文译自<a href="https://www.mikeash.com/pyblog/friday-qa-2013-01-25-lets-build-nsobject.html">这里</a>，转载请注明！</p>

<p>在 Cocoa 编程时创建和使用的（几乎）所有类都是以 NSObject 为根基，但它背后都做了什么、是怎么做的呢？今天，我将从零开始创建 NSObject。</p>

<h2>根类(root class)的组成</h2>

<p>准确地说，根类到底做了什么？以 Objective-C 自身的术语描述，有一个准确的要求：根类的第一个实例变量必须是 isa，它指向一个实例(object)的类(class)，在分发消息的时候，它被用来准确找出该实例的类。从严格的编程语言观点来看，这是根类必须要做的。</p>

<p>当然根类只提供这些是不够的，NSObject 提供了更多的。它提供的功能可以分为一下三类：</p>

<ol>
<li><strong>内存管理</strong>：标准的内存管理方法如 <em>retain</em> 和 <em>release</em> 都是在 NSObject 中实现的，<em>alloc</em> 方法也是如此。</li>
<li><strong>内省</strong>：NSObject 提供了很多 Objective-C 运行时方法的包装，例如 <em>class</em>、<em>respondsToSelector:</em> 和 <em>isKindOfClass:</em>。</li>
<li><strong>内置实用方法</strong>：有很多每一个实例都需要实现的方法，例如 <em>isEqual:</em> 和 <em>description</em>。为了保证每一个实例都有这些方法，NSObject 提供了这些方法的默认实现。</li>
</ol>


<h2>代码</h2>

<p>我接下来将要在 MAObject 中实现 NSObject 的功能，源代码在 Github: <a href="https://github.com/mikeash/MAObject">https://github.com/mikeash/MAObject</a></p>

<p>这个代码没有使用 ARC，虽然 ARC 是个好东西，而且应该尽可能使用它，不过在实现根类的时候使用就不太合适，因为根类需要实现内存管理，如果使用 ARC 就把内存管理交给编译器了！</p>

<h3>实例变量</h3>

<p>MAObject 有两个实例变量，第一个是 isa 指针，第二个是实例的引用计数<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">MAObject</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Class</span> <span class="n">isa</span><span class="p">;</span>
</span><span class='line'>    <span class="k">volatile</span> <span class="n">int32_t</span> <span class="n">retainCount</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们将使用 OSAtomic.h 中的方法管理引用计数保证线程安全，这就是为什么这里没有用 NSUInteger 或者类似的声明，而是用了个看起来不寻常的方式。</p>

<p>实际上 NSObject 是把引用计数保存在外面。有一个全局的表（table），标中是实例地址和引用计数映射。这样可以节省内存，因为不在表中的实例的引用计数默认就是1。尽管有这些好处，但是这样实现起来有点复杂并且性能有些慢，所以在这里我就不实现这种方法了。</p>

<h3>内存管理</h3>

<p>MSObject 需要做的第一件事情就是创建实例，主要在 +alloc 中实现完成。（这里我略过了已经弃用的 +allocWithZone: 方法，这个方法实际上会忽略参数，完成 +alloc 同样的工作。）</p>

<p>子类一般很少会重写 +alloc，而是依赖根类来分配内存。这就意味着 MAObject 不仅要为自己分配内存，还要为子类分配内存，完成这个就要利用<strong>类方法中的 self 的值实际上就是消息将会被分发到的类</strong>这一优势。例如代码为 <strong>[SomeSubClass alloc]</strong>，那么 self 就是指向 SomeSubClass。这个类将会被用来使用运行时方法确定需要的内存大小和正确设置 isa 。同时引用计数的值也会被设为1，与创建一个实例的行为相符：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">alloc</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">MAObject</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">class_getInstanceSize</span><span class="p">(</span><span class="n">self</span><span class="p">));</span>
</span><span class='line'>    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">isa</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'>    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">retainCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>retain</strong> 方法很简单，就是使用 <strong>OSAtomicIncrement32</strong> 方法将引用计数加1，然后返回 self：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">retain</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">OSAtomicIncrement32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retainCount</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>release</strong> 方法干的事情多一点，首先将引用计数减1，如果引用计数降为0了，那么实例需要被销毁，所以要调用 <strong>dealloc</strong>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">oneway</span> <span class="kt">void</span><span class="p">)</span><span class="nf">release</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">uint32_t</span> <span class="n">newCount</span> <span class="o">=</span> <span class="n">OSAtomicDecrement32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retainCount</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">newCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="p">[</span><span class="n">self</span> <span class="n">dealloc</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>autorelease</strong> 的实现实际上调用 <strong>NSAutoreleasePool</strong> 将 self 加入当前的 autorelease pool 。Autorelease pool 现在时运行时的一部分，所以这样做不是很直接，但是 autorelease pool 的 API 是私有的，所以这样实现也是目前最好的办法了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">autorelease</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">NSAutoreleasePool</span> <span class="nl">addObject:</span> <span class="n">self</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>retainCount</strong> 方法简单返回引用计数值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">retainCount</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">retainCount</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后是 <strong>dealloc</strong> 方法，通常类的 dealloc 方法清除所有的实例变量，然后调用父类的 dealloc 。所以根类实际上需要释放占用的内存。这里通过调用 free 来完成：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">free</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>还有一些辅助的方法。NSObject 为了一致性提供了一个什么也没做的 init 方法，所以子类通常会调用 [super init]：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>还有一个 new 方法，它只是包装了一下 alloc 和 init ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">new</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[[</span><span class="n">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>还有个空的 finalize 方法。NSObject 把它作为垃圾回收的一部分实现了。不过 MAObject 开始就不支持垃圾回收，不过我在这里加上它只是因为 NSObject 有它：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">finalize</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>内省</h3>

<p>很多内省的方式只是运行时方法的包装，因为这没太大意思，所以我会简单介绍一下运行时方法背后的工作原理。</p>

<p>最简单的内省方法就是 <strong>class</strong> ，它只是返回 isa ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nf">class</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">isa</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从技术上来讲，这样的实现在 isa 是一个标记指针(tagged pointers)<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> 时就会发生错误，更合理的实现应该是调用 object_getClass 方法，它在标记指针时也可以正常工作。</p>

<p>实例方法 superclass 和使用类来调用 superclass 的行为一样，我们也是这么实现的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nf">superclass</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[[</span><span class="n">self</span> <span class="n">class</span><span class="p">]</span> <span class="n">superclass</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>有很多类方法也是内省的一部分，+class 直接返回 self ，实际上它时一个类实例(class object)。这里有些奇怪，但实际上 NSObject 就是这么工作的。[object class] 返回的是实例的类，[MyClass class] 返回的指针指向 MyClass 本身，看起来不一致，实际上 MyClass 也有一个类，他就是 MyClass 的元类(meta class) 。下面是实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nf">class</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>+superclass 方法顾名思义，它是通过调用 class_getSuperclass 实现的，该方法会解析运行时的类结构来找出指向父类的指针：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nf">superclass</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">class_getSuperclass</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>还有一些方法用来查询某个实例的类是否与指定的类相匹配，最简单的一个就是 isMemberOfClass: ，该方法进行严格匹配，会忽略子类，实现如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isMemberOfClass:</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nv">aClass</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">isa</span> <span class="o">==</span> <span class="n">aClass</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>isKindOfClass: 方法会检查子类，所以 [subclassInstance isKindOfClass: [Superclass class]] 会返回 YES 。该方法的返回值与 +isSubclassOfClass: 的返回值完全一样，我们也是通过调用它来实现的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isKindOfClass:</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nv">aClass</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">isa</span> <span class="nl">isSubclassOfClass:</span> <span class="n">aClass</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>+isSubclassOfClass: 方法有点意思，它会从 self 开始向上递归，在每一层比较目标类。如果找到相匹配的，就返回 YES ，如果一直找到类继承机构的顶层也没有匹配的，就返回 NO ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isSubclassOfClass:</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nv">aClass</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(</span><span class="n">Class</span> <span class="n">candidate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span> <span class="n">candidate</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">;</span> <span class="n">candidate</span> <span class="o">=</span> <span class="p">[</span><span class="n">candidate</span> <span class="n">superclass</span><span class="p">])</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">candidate</span> <span class="o">==</span> <span class="n">aClass</span><span class="p">)</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>你可能已经注意到了这里不是很高效，如果你对一个处在很深的继承关系中的类调用该方法，它在返回 NO 之前将会进行很多次循环。因此 isKindOfClass: 会比通常的消息发送慢，在某种情况下会是性能瓶颈，这也是需要避免使用这类方法的原因之一。</p>

<p><strong>respondsToSelector:</strong> 方法只是调用运行时方法 <strong>class_respondsToSelector</strong> ，该方法在类的方法表中依此查找看是否有匹配项：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">respondsToSelector:</span> <span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">class_respondsToSelector</span><span class="p">(</span><span class="n">isa</span><span class="p">,</span> <span class="n">aSelector</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>还有另外一个类方法 <strong>instancesRespondToSelector:</strong> 和上面的方法几乎一样，不过唯一的区别是它的实现传入的是 self 而不是 isa ，在上下文环境中 self 应该是元类(meta class)：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">instancesRespondToSelector:</span> <span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">class_respondsToSelector</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">aSelector</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>与此类似，也有两个 <strong>conformsToProtocol:</strong> 方法，一个是实例方法，另一个是类方法。他们也都是对运行时方法的包装，在这里是去遍历所有类遵循的协议(protocol)表，坚持给定的协议是否在其中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">conformsToProtocol:</span> <span class="p">(</span><span class="n">Protocol</span> <span class="o">*</span><span class="p">)</span><span class="nv">aProtocol</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">class_conformsToProtocol</span><span class="p">(</span><span class="n">isa</span><span class="p">,</span> <span class="n">aProtocol</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">conformsToProtocol:</span> <span class="p">(</span><span class="n">Protocol</span> <span class="o">*</span><span class="p">)</span><span class="nv">protocol</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">class_conformsToProtocol</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">protocol</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>下一个方法是 <strong>methodForSelector:</strong> ，类方法中类型的方法是 <strong>instanceMethodForSelector:</strong> 。他们俩都会调用运行时方法 <strong>class_getMethodImplementation</strong> ，该方法会查找类的函数表，然后返回响应的 IMP ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">IMP</span><span class="p">)</span><span class="nf">methodForSelector:</span> <span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">class_getMethodImplementation</span><span class="p">(</span><span class="n">isa</span><span class="p">,</span> <span class="n">aSelector</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">+</span> <span class="p">(</span><span class="n">IMP</span><span class="p">)</span><span class="nl">instanceMethodForSelector:</span> <span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="n">aSelector</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">class_getMethodImplementation</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">aSelector</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>有趣的一点是 <strong>class_getMethodImplementation</strong> 总是返回一个 IMP ，即使参数是一个不存在的 selector 。当类没有实现某个方法时，它会返回一个特殊的转发 IMP ，这个 IMP 包装好了调用 <strong>forwardInvocation:</strong> 的消息参数。</p>

<p>方法 <strong>methodSignatureForSelector:</strong> 只是对类方法的包装：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSMethodSignature</span> <span class="o">*</span><span class="p">)</span><span class="nf">methodSignatureForSelector:</span> <span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">isa</span> <span class="nl">instanceMethodSignatureForSelector:</span> <span class="n">aSelector</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>而这个类方法也是对运行时方法的包装。它首先获取输入 selector 的 Method 。如果不能得到，那么就表明类没有实现该方法，那么返回 nil 。否则就获取方法类型的 C 字符串表达，并且包装在 <strong>NSMethodSignature</strong> 中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">NSMethodSignature</span> <span class="o">*</span><span class="p">)</span><span class="nf">instanceMethodSignatureForSelector:</span> <span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">Method</span> <span class="n">method</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">aSelector</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">method</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">types</span> <span class="o">=</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">method</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">NSMethodSignature</span> <span class="nl">signatureWithObjCTypes:</span> <span class="n">types</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后是 <strong>performSelector:</strong> 方法，还有两个类似方法用 <strong>withObject:</strong> 去接收参数。他们不是严格意义上的内省方法，但他们都是对底层运行方法的包装。他们只是获取 selector 的 IMP ，强制转换成合适的函数指针类型，然后调用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">performSelector:</span> <span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">IMP</span> <span class="n">imp</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">methodForSelector:</span> <span class="n">aSelector</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">((</span><span class="kt">id</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))</span><span class="n">imp</span><span class="p">)(</span><span class="n">self</span><span class="p">,</span> <span class="n">aSelector</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">performSelector:</span> <span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="nf">withObject:</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">IMP</span> <span class="n">imp</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">methodForSelector:</span> <span class="n">aSelector</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">((</span><span class="kt">id</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">,</span> <span class="kt">id</span><span class="p">))</span><span class="n">imp</span><span class="p">)(</span><span class="n">self</span><span class="p">,</span> <span class="n">aSelector</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">performSelector:</span> <span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="nf">withObject:</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object1</span> <span class="nf">withObject:</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object2</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">IMP</span> <span class="n">imp</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">methodForSelector:</span> <span class="n">aSelector</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">((</span><span class="kt">id</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">,</span> <span class="kt">id</span><span class="p">,</span> <span class="kt">id</span><span class="p">))</span><span class="n">imp</span><span class="p">)(</span><span class="n">self</span><span class="p">,</span> <span class="n">aSelector</span><span class="p">,</span> <span class="n">object1</span><span class="p">,</span> <span class="n">object2</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>内置实用方法</h3>

<p>MAObject 提供了很多方法的默认实现，我们从 <strong>isEqual:</strong> 和 <strong>hash</strong> 两个方法开始，因为它们都是用实例的指针进行唯一性判断：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isEqual:</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span> <span class="o">==</span> <span class="n">object</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">hash</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>任何子类想要实现更复杂的相等判断就要重写这些方法，但是如果子类想要只有和自身相等的情况下就可以使用这些方法。</p>

<p>另外一个方便的方法是 <strong>description</strong> ，我们也有一个默认实现。这个方法只是生成一个类似 <strong>&lt;MAObject: 0xdeadbeef></strong> 的字符串，包含了实例的类和指针：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">description</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span> <span class="s">@&quot;&lt;%@: %p&gt;&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">self</span> <span class="n">class</span><span class="p">],</span> <span class="n">self</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>类方法 <strong>description</strong> 只需要返回类的名字即可，所以调用运行时方法获取类名然后返回即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">description</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithUTF8String:</span> <span class="n">class_getName</span><span class="p">(</span><span class="n">self</span><span class="p">)];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>doesNotRecognizeSelector:</strong> 是一个知道的人比较少的实用方法。它会通过抛异常来让类看起来不会响应某些方法，这在我们创建一些子类必须重写的方法时很有用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">subclassesMustOverride</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// pretend we don&#39;t actually implement this here</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">doesNotRecognizeSelector:</span> <span class="n">_cmd</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码很简单，唯一有些技巧的地方就是正确给出方法的名称，我们想为实例输出类似 <strong>&ndash;[Class method]</strong> 的东西，同时类方法前面需要显示 <strong>+</strong> ，类似 <strong>+[Class classMethod]</strong> 。为了分辨是哪种情况，我们就需要检查 isa 是不是元类，如果是元类，那么 self 就是类，需要显示 <strong>+</strong> 。否则 self 就是实例，需要用 <strong>&ndash;</strong> 。代码其他部分就是用来抛异常：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">doesNotRecognizeSelector:</span> <span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="o">*</span><span class="n">methodTypeString</span> <span class="o">=</span> <span class="n">class_isMetaClass</span><span class="p">(</span><span class="n">isa</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;+&quot;</span> <span class="o">:</span> <span class="s">&quot;-&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">NSException</span> <span class="nl">raise:</span> <span class="n">NSInvalidArgumentException</span> <span class="nl">format:</span> <span class="s">@&quot;%s[%@ %@]: unrecognized selector sent to instance %p&quot;</span><span class="p">,</span> <span class="n">methodTypeString</span><span class="p">,</span> <span class="p">[[</span><span class="n">self</span> <span class="n">class</span><span class="p">]</span> <span class="n">description</span><span class="p">],</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">aSelector</span><span class="p">),</span> <span class="n">self</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后，还有很多显而易见的方法（比如 self 方法），很多让子类安全调用 <strong>super</strong> 的方法（类似空的 <strong>+initialize</strong> 方法），很多重写点（例如 <strong>copy</strong> 就会抛异常）。这些都没太多意思，但都包括在了 MAObject 中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">self</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isProxy</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">load</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">initialize</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">copy</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">doesNotRecognizeSelector:</span> <span class="n">_cmd</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">mutableCopy</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">doesNotRecognizeSelector:</span> <span class="n">_cmd</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">forwardingTargetForSelector:</span> <span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">forwardInvocation:</span> <span class="p">(</span><span class="n">NSInvocation</span> <span class="o">*</span><span class="p">)</span><span class="nv">anInvocation</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">doesNotRecognizeSelector:</span> <span class="p">[</span><span class="n">anInvocation</span> <span class="n">selector</span><span class="p">]];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">resolveClassMethod:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">sel</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">resolveInstanceMethod:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">sel</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>总结</h2>

<p>NSObject 其实就是一大堆不同函数的组合，没什么奇怪之处。它的主要功能就是分配和管理内存，你可据此创建实例。同时它也提供了一堆每个方法都应该支持的有用的重写点，也包装了很多有用的运行时 API 。</p>

<p>这里我忽略了 NSObject 的一个块内容：key-value coding ，这块复杂到我需要另写<a href="https://www.mikeash.com/pyblog/friday-qa-2013-02-08-lets-build-key-value-coding.html">一篇文章</a>了。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>NSObject 的实现有些不同，具体可以参考实现源码：<a href="http://opensource.apple.com/source/objc4/objc4-532.2/runtime/NSObject.mm">http://opensource.apple.com/source/objc4/objc4-532.2/runtime/NSObject.mm</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>详情请参考<a href="http://en.wikipedia.org/wiki/Tagged_pointer">http://en.wikipedia.org/wiki/Tagged_pointer</a>和<a href="https://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html">https://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Yong Li</span></span>

      








  


<time datetime="2014-03-09T00:16:54+08:00" pubdate data-updated="true">Mar 9<span>th</span>, 2014</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/ios/'>ios</a>, <a class='category' href='/blog/categories/programming/'>programming</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/02/17/ios-frp/" title="Previous Post: iOS 的 ReactiveCocoa 函数式响应编程">&laquo; iOS 的 ReactiveCocoa 函数式响应编程</a>
      
      
        <a class="basic-alignment right" href="/blog/2014/04/27/ios-performance/" title="Next Post: iOS App 性能备忘">iOS App 性能备忘 &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/06/01/facebook-shimmer/">Facebook Shimmer 实现原理</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/04/27/ios-performance/">iOS App 性能备忘</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/03/09/lets-build-nsobject/">动手创建 NSObject</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/02/17/ios-frp/">iOS 的 ReactiveCocoa 函数式响应编程</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/01/11/my-2013/">我的 2013</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Yong Li -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'liyong03';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://liyong03.github.io/blog/2014/03/09/lets-build-nsobject/';
        var disqus_url = 'http://liyong03.github.io/blog/2014/03/09/lets-build-nsobject/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
