<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Yong的Blog]]></title>
  <link href="http://liyong03.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://liyong03.github.io/"/>
  <updated>2014-04-29T08:22:02+08:00</updated>
  <id>http://liyong03.github.io/</id>
  <author>
    <name><![CDATA[Yong Li]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[动手创建 NSObject]]></title>
    <link href="http://liyong03.github.io/blog/2014/03/09/lets-build-nsobject/"/>
    <updated>2014-03-09T00:16:54+08:00</updated>
    <id>http://liyong03.github.io/blog/2014/03/09/lets-build-nsobject</id>
    <content type="html"><![CDATA[<p>本文译自<a href="https://www.mikeash.com/pyblog/friday-qa-2013-01-25-lets-build-nsobject.html">这里</a>，转载请注明！</p>

<p>在 Cocoa 编程时创建和使用的（几乎）所有类都是以 NSObject 为根基，但它背后都做了什么、是怎么做的呢？今天，我将从零开始创建 NSObject。</p>

<h2>根类(root class)的组成</h2>

<p>准确地说，根类到底做了什么？以 Objective-C 自身的术语描述，有一个准确的要求：根类的第一个实例变量必须是 isa，它指向一个实例(object)的类(class)，在分发消息的时候，它被用来准确找出该实例的类。从严格的编程语言观点来看，这是根类必须要做的。</p>

<p>当然根类只提供这些是不够的，NSObject 提供了更多的。它提供的功能可以分为一下三类：</p>

<ol>
<li><strong>内存管理</strong>：标准的内存管理方法如 <em>retain</em> 和 <em>release</em> 都是在 NSObject 中实现的，<em>alloc</em> 方法也是如此。</li>
<li><strong>内省</strong>：NSObject 提供了很多 Objective-C 运行时方法的包装，例如 <em>class</em>、<em>respondsToSelector:</em> 和 <em>isKindOfClass:</em>。</li>
<li><strong>内置实用方法</strong>：有很多每一个实例都需要实现的方法，例如 <em>isEqual:</em> 和 <em>description</em>。为了保证每一个实例都有这些方法，NSObject 提供了这些方法的默认实现。</li>
</ol>


<h2>代码</h2>

<p>我接下来将要在 MAObject 中实现 NSObject 的功能，源代码在 Github: <a href="https://github.com/mikeash/MAObject">https://github.com/mikeash/MAObject</a></p>

<p>这个代码没有使用 ARC，虽然 ARC 是个好东西，而且应该尽可能使用它，不过在实现根类的时候使用就不太合适，因为根类需要实现内存管理，如果使用 ARC 就把内存管理交给编译器了！</p>

<h3>实例变量</h3>

<p>MAObject 有两个实例变量，第一个是 isa 指针，第二个是实例的引用计数<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>：</p>

<p>``` objc</p>

<pre><code>@implementation MAObject {
    Class isa;
    volatile int32_t retainCount;
}
</code></pre>

<p>```</p>

<p>我们将使用 OSAtomic.h 中的方法管理引用计数保证线程安全，这就是为什么这里没有用 NSUInteger 或者类似的声明，而是用了个看起来不寻常的方式。</p>

<p>实际上 NSObject 是把引用计数保存在外面。有一个全局的表（table），标中是实例地址和引用计数映射。这样可以节省内存，因为不在表中的实例的引用计数默认就是1。尽管有这些好处，但是这样实现起来有点复杂并且性能有些慢，所以在这里我就不实现这种方法了。</p>

<h3>内存管理</h3>

<p>MSObject 需要做的第一件事情就是创建实例，主要在 +alloc 中实现完成。（这里我略过了已经弃用的 +allocWithZone: 方法，这个方法实际上会忽略参数，完成 +alloc 同样的工作。）</p>

<p>子类一般很少会重写 +alloc，而是依赖根类来分配内存。这就意味着 MAObject 不仅要为自己分配内存，还要为子类分配内存，完成这个就要利用<strong>类方法中的 self 的值实际上就是消息将会被分发到的类</strong>这一优势。例如代码为 <strong>[SomeSubClass alloc]</strong>，那么 self 就是指向 SomeSubClass。这个类将会被用来使用运行时方法确定需要的内存大小和正确设置 isa 。同时引用计数的值也会被设为1，与创建一个实例的行为相符：</p>

<p>``` objc</p>

<pre><code>+ (id)alloc
{
    MAObject *obj = calloc(1, class_getInstanceSize(self));
    obj-&gt;isa = self;
    obj-&gt;retainCount = 1;
    return obj;
}
</code></pre>

<p>```</p>

<p><strong>retain</strong> 方法很简单，就是使用 <strong>OSAtomicIncrement32</strong> 方法将引用计数加1，然后返回 self：
``` objc</p>

<pre><code>- (id)retain
{
    OSAtomicIncrement32(&amp;retainCount);
    return self;
}
</code></pre>

<p>```</p>

<p><strong>release</strong> 方法干的事情多一点，首先将引用计数减1，如果引用计数降为0了，那么实例需要被销毁，所以要调用 <strong>dealloc</strong>：</p>

<p>``` objc</p>

<pre><code>- (oneway void)release
{
    uint32_t newCount = OSAtomicDecrement32(&amp;retainCount);
    if(newCount == 0)
        [self dealloc];
}
</code></pre>

<p>```</p>

<p><strong>autorelease</strong> 的实现实际上调用 <strong>NSAutoreleasePool</strong> 将 self 加入当前的 autorelease pool 。Autorelease pool 现在时运行时的一部分，所以这样做不是很直接，但是 autorelease pool 的 API 是私有的，所以这样实现也是目前最好的办法了：</p>

<p>``` objc</p>

<pre><code>- (id)autorelease
{
    [NSAutoreleasePool addObject: self];
    return self;
}
</code></pre>

<p>```</p>

<p><strong>retainCount</strong> 方法简单返回引用计数值：</p>

<p>``` objc</p>

<pre><code>- (NSUInteger)retainCount
{
    return retainCount;
}
</code></pre>

<p>```</p>

<p>最后是 <strong>dealloc</strong> 方法，通常类的 dealloc 方法清除所有的实例变量，然后调用父类的 dealloc 。所以根类实际上需要释放占用的内存。这里通过调用 free 来完成：</p>

<p>``` objc</p>

<pre><code>- (void)dealloc
{
    free(self);
}
</code></pre>

<p>```</p>

<p>还有一些辅助的方法。NSObject 为了一致性提供了一个什么也没做的 init 方法，所以子类通常会调用 [super init]：</p>

<p>``` objc</p>

<pre><code>- (id)init
{
    return self;
}
</code></pre>

<p>```</p>

<p>还有一个 new 方法，它只是包装了一下 alloc 和 init ：</p>

<p>``` objc</p>

<pre><code>+ (id)new
{
    return [[self alloc] init];
}
</code></pre>

<p>```</p>

<p>还有个空的 finalize 方法。NSObject 把它作为垃圾回收的一部分实现了。不过 MAObject 开始就不支持垃圾回收，不过我在这里加上它只是因为 NSObject 有它：</p>

<p>``` objc</p>

<pre><code>- (void)finalize
{
}
</code></pre>

<p>```</p>

<h3>内省</h3>

<p>很多内省的方式只是运行时方法的包装，因为这没太大意思，所以我会简单介绍一下运行时方法背后的工作原理。</p>

<p>最简单的内省方法就是 <strong>class</strong> ，它只是返回 isa ：</p>

<p>``` objc</p>

<pre><code>- (Class)class
{
    return isa;
}
</code></pre>

<p>```</p>

<p>从技术上来讲，这样的实现在 isa 是一个标记指针(tagged pointers)<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> 时就会发生错误，更合理的实现应该是调用 object_getClass 方法，它在标记指针时也可以正常工作。</p>

<p>实例方法 superclass 和使用类来调用 superclass 的行为一样，我们也是这么实现的：</p>

<p>``` objc</p>

<pre><code>- (Class)superclass
{
    return [[self class] superclass];
}
</code></pre>

<p>```</p>

<p>有很多类方法也是内省的一部分，+class 直接返回 self ，实际上它时一个类实例(class object)。这里有些奇怪，但实际上 NSObject 就是这么工作的。[object class] 返回的是实例的类，[MyClass class] 返回的指针指向 MyClass 本身，看起来不一致，实际上 MyClass 也有一个类，他就是 MyClass 的元类(meta class) 。下面是实现：</p>

<p>``` objc</p>

<pre><code>+ (Class)class
{
    return self;
}
</code></pre>

<p>```</p>

<p>+superclass 方法顾名思义，它是通过调用 class_getSuperclass 实现的，该方法会解析运行时的类结构来找出指向父类的指针：</p>

<p>``` objc</p>

<pre><code>+ (Class)superclass
{
    return class_getSuperclass(self);
}
</code></pre>

<p>```</p>

<p>还有一些方法用来查询某个实例的类是否与指定的类相匹配，最简单的一个就是 isMemberOfClass: ，该方法进行严格匹配，会忽略子类，实现如下：</p>

<p>``` objc</p>

<pre><code>- (BOOL)isMemberOfClass: (Class)aClass
{
    return isa == aClass;
}
</code></pre>

<p>```</p>

<p>isKindOfClass: 方法会检查子类，所以 [subclassInstance isKindOfClass: [Superclass class]] 会返回 YES 。该方法的返回值与 +isSubclassOfClass: 的返回值完全一样，我们也是通过调用它来实现的：</p>

<p>``` objc</p>

<pre><code>- (BOOL)isKindOfClass: (Class)aClass
{
    return [isa isSubclassOfClass: aClass];
}
</code></pre>

<p>```</p>

<p>+isSubclassOfClass: 方法有点意思，它会从 self 开始向上递归，在每一层比较目标类。如果找到相匹配的，就返回 YES ，如果一直找到类继承机构的顶层也没有匹配的，就返回 NO ：</p>

<p>``` objc</p>

<pre><code>+ (BOOL)isSubclassOfClass: (Class)aClass
{
    for(Class candidate = self; candidate != nil; candidate = [candidate superclass])
        if (candidate == aClass)
            return YES;
    return NO;
}
</code></pre>

<p>```
你可能已经注意到了这里不是很高效，如果你对一个处在很深的继承关系中的类调用该方法，它在返回 NO 之前将会进行很多次循环。因此 isKindOfClass: 会比通常的消息发送慢，在某种情况下会是性能瓶颈，这也是需要避免使用这类方法的原因之一。</p>

<p><strong>respondsToSelector:</strong> 方法只是调用运行时方法 <strong>class_respondsToSelector</strong> ，该方法在类的方法表中依此查找看是否有匹配项：</p>

<p>``` objc</p>

<pre><code>- (BOOL)respondsToSelector: (SEL)aSelector
{
    return class_respondsToSelector(isa, aSelector);
}
</code></pre>

<p>```</p>

<p>还有另外一个类方法 <strong>instancesRespondToSelector:</strong> 和上面的方法几乎一样，不过唯一的区别是它的实现传入的是 self 而不是 isa ，在上下文环境中 self 应该是元类(meta class)：</p>

<p>``` objc</p>

<pre><code>+ (BOOL)instancesRespondToSelector: (SEL)aSelector
{
    return class_respondsToSelector(self, aSelector);
}
</code></pre>

<p>```</p>

<p>与此类似，也有两个 <strong>conformsToProtocol:</strong> 方法，一个是实例方法，另一个是类方法。他们也都是对运行时方法的包装，在这里是去遍历所有类遵循的协议(protocol)表，坚持给定的协议是否在其中：</p>

<p>``` objc</p>

<pre><code>- (BOOL)conformsToProtocol: (Protocol *)aProtocol
{
    return class_conformsToProtocol(isa, aProtocol);
}

+ (BOOL)conformsToProtocol: (Protocol *)protocol
{
    return class_conformsToProtocol(self, protocol);
}
</code></pre>

<p>```</p>

<p>下一个方法是 <strong>methodForSelector:</strong> ，类方法中类型的方法是 <strong>instanceMethodForSelector:</strong> 。他们俩都会调用运行时方法 <strong>class_getMethodImplementation</strong> ，该方法会查找类的函数表，然后返回响应的 IMP ：</p>

<p>``` objc
&ndash; (IMP)methodForSelector: (SEL)aSelector</p>

<pre><code>{
    return class_getMethodImplementation(isa, aSelector);
}

+ (IMP)instanceMethodForSelector: (SEL)aSelector
{
    return class_getMethodImplementation(self, aSelector);
}
</code></pre>

<p>```</p>

<p>有趣的一点是 <strong>class_getMethodImplementation</strong> 总是返回一个 IMP ，即使参数是一个不存在的 selector 。当类没有实现某个方法时，它会返回一个特殊的转发 IMP ，这个 IMP 包装好了调用 <strong>forwardInvocation:</strong> 的消息参数。</p>

<p>方法 <strong>methodSignatureForSelector:</strong> 只是对类方法的包装：</p>

<p>``` objc</p>

<pre><code>- (NSMethodSignature *)methodSignatureForSelector: (SEL)aSelector
{
    return [isa instanceMethodSignatureForSelector: aSelector];
}
</code></pre>

<p>```</p>

<p>而这个类方法也是对运行时方法的包装。它首先获取输入 selector 的 Method 。如果不能得到，那么就表明类没有实现该方法，那么返回 nil 。否则就获取方法类型的 C 字符串表达，并且包装在 <strong>NSMethodSignature</strong> 中：</p>

<p>``` objc</p>

<pre><code>+ (NSMethodSignature *)instanceMethodSignatureForSelector: (SEL)aSelector
{
    Method method = class_getInstanceMethod(self, aSelector);
    if(!method)
        return nil;

    const char *types = method_getTypeEncoding(method);
    return [NSMethodSignature signatureWithObjCTypes: types];
}
</code></pre>

<p>```</p>

<p>最后是 <strong>performSelector:</strong> 方法，还有两个类似方法用 <strong>withObject:</strong> 去接收参数。他们不是严格意义上的内省方法，但他们都是对底层运行方法的包装。他们只是获取 selector 的 IMP ，强制转换成合适的函数指针类型，然后调用：</p>

<p>``` objc</p>

<pre><code>- (id)performSelector: (SEL)aSelector
{
    IMP imp = [self methodForSelector: aSelector];
    return ((id (*)(id, SEL))imp)(self, aSelector);
}

- (id)performSelector: (SEL)aSelector withObject: (id)object
{
    IMP imp = [self methodForSelector: aSelector];
    return ((id (*)(id, SEL, id))imp)(self, aSelector, object);
}

- (id)performSelector: (SEL)aSelector withObject: (id)object1 withObject: (id)object2
{
    IMP imp = [self methodForSelector: aSelector];
    return ((id (*)(id, SEL, id, id))imp)(self, aSelector, object1, object2);
}
</code></pre>

<p>```</p>

<h3>内置实用方法</h3>

<p>MAObject 提供了很多方法的默认实现，我们从 <strong>isEqual:</strong> 和 <strong>hash</strong> 两个方法开始，因为它们都是用实例的指针进行唯一性判断：</p>

<p>``` objc</p>

<pre><code>- (BOOL)isEqual: (id)object
{
    return self == object;
}

- (NSUInteger)hash
{
    return (NSUInteger)self;
}
</code></pre>

<p>```</p>

<p>任何子类想要实现更复杂的相等判断就要重写这些方法，但是如果子类想要只有和自身相等的情况下就可以使用这些方法。</p>

<p>另外一个方便的方法是 <strong>description</strong> ，我们也有一个默认实现。这个方法只是生成一个类似 <strong>&lt;MAObject: 0xdeadbeef></strong> 的字符串，包含了实例的类和指针：</p>

<p>``` objc</p>

<pre><code>- (NSString *)description
{
    return [NSString stringWithFormat: @"&lt;%@: %p&gt;", [self class], self];
}
</code></pre>

<p>```</p>

<p>类方法 <strong>description</strong> 只需要返回类的名字即可，所以调用运行时方法获取类名然后返回即可：</p>

<p>``` objc</p>

<pre><code>+ (NSString *)description
{
    return [NSString stringWithUTF8String: class_getName(self)];
}
</code></pre>

<p>```</p>

<p><strong>doesNotRecognizeSelector:</strong> 是一个知道的人比较少的实用方法。它会通过抛异常来让类看起来不会响应某些方法，这在我们创建一些子类必须重写的方法时很有用：</p>

<p>``` objc</p>

<pre><code>- (void)subclassesMustOverride
{
    // pretend we don't actually implement this here
    [self doesNotRecognizeSelector: _cmd];
}
</code></pre>

<p>```</p>

<p>代码很简单，唯一有些技巧的地方就是正确给出方法的名称，我们想为实例输出类似 <strong>&ndash;[Class method]</strong> 的东西，同时类方法前面需要显示 <strong>+</strong> ，类似 <strong>+[Class classMethod]</strong> 。为了分辨是哪种情况，我们就需要检查 isa 是不是元类，如果是元类，那么 self 就是类，需要显示 <strong>+</strong> 。否则 self 就是实例，需要用 <strong>&ndash;</strong> 。代码其他部分就是用来抛异常：</p>

<p>``` objc</p>

<pre><code>- (void)doesNotRecognizeSelector: (SEL)aSelector
{
    char *methodTypeString = class_isMetaClass(isa) ? "+" : "-";
    [NSException raise: NSInvalidArgumentException format: @"%s[%@ %@]: unrecognized selector sent to instance %p", methodTypeString, [[self class] description], NSStringFromSelector(aSelector), self];
}
</code></pre>

<p>```</p>

<p>最后，还有很多显而易见的方法（比如 self 方法），很多让子类安全调用 <strong>super</strong> 的方法（类似空的 <strong>+initialize</strong> 方法），很多重写点（例如 <strong>copy</strong> 就会抛异常）。这些都没太多意思，但都包括在了 MAObject 中：</p>

<p>``` objc</p>

<pre><code>- (id)self
{
    return self;
}

- (BOOL)isProxy
{
    return NO;
}

+ (void)load
{
}

+ (void)initialize
{
}

- (id)copy
{
    [self doesNotRecognizeSelector: _cmd];
    return nil;
}

- (id)mutableCopy
{
    [self doesNotRecognizeSelector: _cmd];
    return nil;
}

- (id)forwardingTargetForSelector: (SEL)aSelector
{
    return nil;
}

- (void)forwardInvocation: (NSInvocation *)anInvocation
{
    [self doesNotRecognizeSelector: [anInvocation selector]];
}

+ (BOOL)resolveClassMethod:(SEL)sel
{
    return NO;
}

+ (BOOL)resolveInstanceMethod:(SEL)sel
{
    return NO;
}
</code></pre>

<p>```</p>

<h2>总结</h2>

<p>NSObject 其实就是一大堆不同函数的组合，没什么奇怪之处。它的主要功能就是分配和管理内存，你可据此创建实例。同时它也提供了一堆每个方法都应该支持的有用的重写点，也包装了很多有用的运行时 API 。</p>

<p>这里我忽略了 NSObject 的一个块内容：key-value coding ，这块复杂到我需要另写<a href="https://www.mikeash.com/pyblog/friday-qa-2013-02-08-lets-build-key-value-coding.html">一篇文章</a>了。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>NSObject 的实现有些不同，具体可以参考实现源码：<a href="http://opensource.apple.com/source/objc4/objc4-532.2/runtime/NSObject.mm">http://opensource.apple.com/source/objc4/objc4-532.2/runtime/NSObject.mm</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>详情请参考<a href="http://en.wikipedia.org/wiki/Tagged_pointer">http://en.wikipedia.org/wiki/Tagged_pointer</a>和<a href="https://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html">https://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 的 ReactiveCocoa 函数式响应编程]]></title>
    <link href="http://liyong03.github.io/blog/2014/02/17/ios-frp/"/>
    <updated>2014-02-17T23:33:11+08:00</updated>
    <id>http://liyong03.github.io/blog/2014/02/17/ios-frp</id>
    <content type="html"><![CDATA[<p>本文翻译自<a href="http://www.teehanlax.com/blog/reactivecocoa/">这里</a>，其中一些语法由于 ReactiveCocoa 的演进我做了修改。</p>

<p>Objective-C 是一种基于C语言、但又常常深陷于C的过时编程方式的编程语言。随着计算机计算能力的提升，编程语言设计也与时俱进，但是Objective-C有时好像留在了过去。</p>

<p>Objective-C和C都属于计算机顺序执行软件指令的<a href="http://en.wikipedia.org/wiki/Imperative_programming">指令式编程语言</a>，软件的行为也出自执行这些指令。如果开发者写出来正确顺序的指令，那么软件的行为也满足程序的期望。</p>

<p>但是写出来的代码总是有缺陷，我们需要使用或是手动或是自动的测试去减少这些问题，但是如果能抽象单独的指令，而把注意力放在期望行为上面。这就是<a href="http://en.wikipedia.org/wiki/Declarative_programming">声明式编程</a>的由来。</p>

<p>指令范式强制让开发者写程序去完成一些任务，而声明范式解放开发者去描述任务是什么。</p>

<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>是一种让 Objective-C 少一些指令式属性，多一些响应式属性。它将<em>怎样</em>抽象成<em>什么</em>。</p>

<p>下面我们用几个例子来展示 Objective-C 中的声明式编程是什么样的。</p>

<p>ReactiveCocoa 的核心是<em>信号 (signal)</em> ，信号代表了不同时间发生的事件流。<em>订阅 (subscribing)</em> 信号允许开发者访问这些事件。下面开看一个基础的例子。</p>

<p>iOS App 中得输入框(Text Field)在输入文字发生改变时会产生的事件会生成信号。ReactiveCocoa 的 UITextField 分类(Category)有一个方法：<em>rac_textSignal</em>，我们可以这样订阅这个事件：</p>

<p>``` objc</p>

<pre><code>[self.usernameField.rac_textSignal subscribeNext:^(NSString *value) {
    NSLog(@"Text field has been updated: %@", value);
}];
</code></pre>

<p>```</p>

<p>这段代码中，我们声明输入框的文字变化时，将它的新值打印出来。无论何时输入框的信号发送了一个事件，这块代码都将被以新的文本内容为参数调用。</p>

<p><img src="/images/subscription.png" alt="subscription" /></p>

<p>信号很牛逼的地方在于它可以组合使用。我们可以过滤 <em>rac_textSignal</em> 返回的信号，以保证字符串的长度大于3才能登陆：</p>

<p>``` objc</p>

<pre><code>[[self.textField.rac_textSignal filter:^BOOL(NSString *value) {
    return [value length] &gt;= 3;
}] subscribeNext:^(NSString *value) {
    NSLog(@"Text field has been updated: %@", value);
}];
</code></pre>

<p>```</p>

<p>Filter 方法返回一个新的信号。当第一个信号发射了一个事件，这个事件的值将被传递到 <em>filter</em> 代码块。如果这块代发返回 YES，那么新的信号会发射一个事件。后代码订阅的就是这个 filter 返回的信号。</p>

<p><img src="/images/filter.png" alt="filter" /></p>

<p>我们来做一些更复杂的吧。我们将两个输入框的两个信号<em>联合 (combine)</em> 起来，将他们的值<em>降 (reduce)</em> 为一个布尔值，然后和另一个按钮的 <em>enable</em> 属性<em>绑定 (bind)</em> 在一起。</p>

<p>``` objc</p>

<pre><code>[[RACSignal combineLatest:@[self.firstNameField.rac_textSignal, self.lastNameField.rac_textSignal]
    reduce:^(NSString *firstName, NSString *lastName){
        return @(firstName.length &gt; 0 &amp;&amp; lastName.length &gt; 0);
    }] setKeyPath:@"enabled" onObject:self.button];
</code></pre>

<p>```</p>

<p>按钮的 enable 状态总是由两个输入框的最新的信号所派生。这代表了函数响应式编程众多核心理念中的一个：派生状态(deriving state)。</p>

<p><img src="/images/combine.png" alt="combine" /></p>

<p>在上述所有例子中，我们都在 <strong>viewDidLoad</strong> 中有所声明，在应用运行时这些陈述都保持为真。这里我们没有实现任何代理方法(delegate methods)或者保存任何状态。所有行为都是显式声明而不是隐式的推断。</p>

<p>函数响应式编程非常复杂，而学习 ReactiveCocoa 的丰富细节也需要时间。但是学习这些也会带来具有可预测的、良好定义行为的稳定程序。</p>

<p>软件开发的历史告诉我们软件开发的趋势是朝着更高级别的抽象迈进，诚如我们现在再也不会和穿孔卡片或者汇编语言打交道一样。我相信函数响应式编程是抽象的另一个更高层次，借此程序员可以更快地开发出更好地软件。</p>
]]></content>
  </entry>
  
</feed>
