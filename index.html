
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Yong的Blog</title>
  <meta name="author" content="Yong Li">

  
  <meta name="description" content="本文译自这里. iOS App 性能备忘 本备忘收集了很多可以提高 iOS 中 Objective-C 代码性能的代码片段和配置 这些文档中大部分代码片段和配置包括：将平时随手使用会用到的优先考虑灵活性而不是性能的高级 API，替换为功能相同的底层 API；一些会影响到绘制性能的类属性配置。对于 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://liyong03.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Yong的Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-47130724-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Yong的Blog</a></h1>
  
    <h2>技术生活随想</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:liyong03.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/27/ios-performance/">iOS App 性能备忘</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-27T11:04:22+08:00" pubdate data-updated="true">Apr 27<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/04/27/ios-performance/#disqus_thread"
             data-disqus-identifier="http://liyong03.github.io/blog/2014/04/27/ios-performance/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>本文译自<a href="https://github.com/danielamitay/iOS-App-Performance-Cheatsheet">这里</a>.</p>

<h1>iOS App 性能备忘</h1>

<p><strong>本备忘收集了很多可以提高 iOS 中 Objective-C 代码性能的代码片段和配置</strong></p>

<p>这些文档中大部分代码片段和配置包括：将平时随手使用会用到的优先考虑灵活性而不是性能的高级 API，替换为功能相同的底层 API；一些会影响到绘制性能的类属性配置。对于 app 性能来说，好的架构和恰当的多线程总是很重要的，但是有时需要具体问题具体对待。</p>

<h3>目录</h3>

<p><strong>iOS App 性能备忘</strong> 按照 Objective-C framework 组织为不同章节的 Markdown 文件：</p>

<ul>
<li><a href="Foundation.md"><strong>Foundation</strong></a>

<ul>
<li><a href="Foundation.md#nsdateformatter">NSDateFormatter</a></li>
<li><a href="Foundation.md#nsfilemanager">NSFileManager</a></li>
<li><a href="Foundation.md#nsobjcruntime">NSObjCRuntime</a></li>
<li><a href="Foundation.md#nsstring">NSString</a></li>
</ul>
</li>
<li><a href="UIKit.md"><strong>UIKit</strong></a>

<ul>
<li><a href="UIKit.md#uiimage">UIImage</a></li>
<li><a href="UIKit.md#uiview">UIView</a></li>
</ul>
</li>
<li><a href="QuartzCore.md"><strong>QuartzCore</strong></a>

<ul>
<li><a href="QuartzCore.md#calayer">CALayer</a></li>
</ul>
</li>
</ul>


<h1>Foundation</h1>

<ul>
<li><a href="#nsdateformatter">NSDateFormatter</a></li>
<li><a href="#nsfilemanager">NSFileManager</a></li>
<li><a href="#nsobjcruntime">NSObjCRuntime</a></li>
<li><a href="#nsstring">NSString</a></li>
</ul>


<hr />

<h3>NSDateFormatter</h3>

<p><code>NSDateFormatter</code> 不是唯一一个创建的开销就很昂贵的类，但是它却是常用的、开销大到 Apple 会特别建议应该缓存和重复使用实例的一个。</p>

<blockquote><p>Creating a date formatter is not a cheap operation. If you are likely to use a formatter frequently, it is typically more efficient to cache a single instance than to create and dispose of multiple instances. One approach is to use a static variable.</p></blockquote>

<p><a href="https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/DataFormatting/Articles/dfDateFormatting10_4.html">Source</a></p>

<p>一种通用的缓存 <code>NSDateFormatter</code> 的方法是使用 <code>-[NSThread threadDictionary]</code>（因为 <code>NSDateFormatter</code> 不是线程安全的）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">NSDateFormatter</span> <span class="o">*</span><span class="p">)</span><span class="nf">cachedDateFormatter</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">threadDictionary</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]</span> <span class="n">threadDictionary</span><span class="p">];</span>
</span><span class='line'>  <span class="n">NSDateFormatter</span> <span class="o">*</span><span class="n">dateFormatter</span> <span class="o">=</span> <span class="p">[</span><span class="n">threadDictionary</span> <span class="nl">objectForKey:</span><span class="s">@&quot;cachedDateFormatter&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">dateFormatter</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">dateFormatter</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSDateFormatter</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">dateFormatter</span> <span class="nl">setLocale:</span><span class="p">[</span><span class="n">NSLocale</span> <span class="n">currentLocale</span><span class="p">]];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">dateFormatter</span> <span class="nl">setDateFormat:</span> <span class="s">@&quot;YYYY-MM-dd HH:mm:ss&quot;</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">threadDictionary</span> <span class="nl">setObject:</span><span class="n">dateFormatter</span> <span class="nl">forKey:</span><span class="s">@&quot;cachedDateFormatter&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">dateFormatter</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h5>&ndash; (NSDate <em>)dateFromString:(NSString </em>)string</h5>

<p>这可能是最常见的 iOS 性能瓶颈。经过多方努力寻找，下面是 <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601</a> 转成 <code>NSDate</code> 的 <code>NSDateFormatter</code> 的最著名替代品。</p>

<h6>strptime</h6>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//#include &lt;time.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">time_t</span> <span class="n">t</span><span class="p">;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">tm</span> <span class="n">tm</span><span class="p">;</span>
</span><span class='line'><span class="n">strptime</span><span class="p">([</span><span class="n">iso8601String</span> <span class="nl">cStringUsingEncoding:</span><span class="n">NSUTF8StringEncoding</span><span class="p">],</span> <span class="s">&quot;%Y-%m-%dT%H:%M:%S%z&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tm</span><span class="p">);</span>
</span><span class='line'><span class="n">tm</span><span class="p">.</span><span class="n">tm_isdst</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="n">t</span> <span class="o">=</span> <span class="n">mktime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tm</span><span class="p">);</span>
</span><span class='line'><span class="p">[</span><span class="n">NSDate</span> <span class="nl">dateWithTimeIntervalSince1970:</span><span class="n">t</span> <span class="o">+</span> <span class="p">[[</span><span class="n">NSTimeZone</span> <span class="n">localTimeZone</span><span class="p">]</span> <span class="n">secondsFromGMT</span><span class="p">]];</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="http://sam.roon.io/how-to-drastically-improve-your-app-with-an-afternoon-and-instruments">Source</a></p>

<h6>sqlite3</h6>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//#import &quot;sqlite3.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">sqlite3</span> <span class="o">*</span><span class="n">db</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="n">sqlite3_open</span><span class="p">(</span><span class="s">&quot;:memory:&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">db</span><span class="p">);</span>
</span><span class='line'><span class="n">sqlite3_stmt</span> <span class="o">*</span><span class="n">statement</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="n">sqlite3_prepare_v2</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="s">&quot;SELECT strftime(&#39;%s&#39;, ?);&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">statement</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'><span class="n">sqlite3_bind_text</span><span class="p">(</span><span class="n">statement</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">iso8601String</span> <span class="n">UTF8String</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">SQLITE_STATIC</span><span class="p">);</span>
</span><span class='line'><span class="n">sqlite3_step</span><span class="p">(</span><span class="n">statement</span><span class="p">);</span>
</span><span class='line'><span class="n">int64_t</span> <span class="n">value</span> <span class="o">=</span> <span class="n">sqlite3_column_int64</span><span class="p">(</span><span class="n">statement</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="n">NSDate</span> <span class="o">*</span><span class="n">date</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSDate</span> <span class="nl">dateWithTimeIntervalSince1970:</span><span class="n">value</span><span class="p">];</span>
</span><span class='line'><span class="n">sqlite3_clear_bindings</span><span class="p">(</span><span class="n">statement</span><span class="p">);</span>
</span><span class='line'><span class="n">sqlite3_reset</span><span class="p">(</span><span class="n">statement</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="http://vombat.tumblr.com/post/60530544401/date-parsing-performance-on-ios-nsdateformatter-vs">Source</a></p>

<h3>NSFileManager</h3>

<h5>&ndash; (NSDictionary <em>)attributesOfItemAtPath:(NSString </em>)filePath error:(NSError *)error</h5>

<p>当试图获取磁盘中一个文件的属性信息时，使用 <code>–[NSFileManager attributesOfItemAtPath:error:]</code> 会浪费大量时间读取你可能根本不需要的附加属性。这时你可以使用 <code>stat</code> 代替 <code>NSFileManager</code>，直接获取文件属性：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">//#import &lt;sys/stat.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">stat</span> <span class="n">statbuf</span><span class="p">;</span>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cpath</span> <span class="o">=</span> <span class="p">[</span><span class="n">filePath</span> <span class="n">fileSystemRepresentation</span><span class="p">];</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">cpath</span> <span class="o">&amp;&amp;</span> <span class="n">stat</span><span class="p">(</span><span class="n">cpath</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">statbuf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSNumber</span> <span class="o">*</span><span class="n">fileSize</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithUnsignedLongLong:</span><span class="n">statbuf</span><span class="p">.</span><span class="n">st_size</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSDate</span> <span class="o">*</span><span class="n">modificationDate</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSDate</span> <span class="nl">dateWithTimeIntervalSince1970:</span><span class="n">statbuf</span><span class="p">.</span><span class="n">st_mtime</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSDate</span> <span class="o">*</span><span class="n">creationDate</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSDate</span> <span class="nl">dateWithTimeIntervalSince1970:</span><span class="n">statbuf</span><span class="p">.</span><span class="n">st_ctime</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// etc</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>NSObjCRuntime</h3>

<h5>NSLog(NSString *format, &hellip;)</h5>

<p><code>NSLog()</code> 写消息到 Apple 的系统日志。当通过 Xcode 变异运行程序时，被写出的日志会展现在调试终端，同事也会写到设备产品终端日志中。此外，系统会在主线程序列化 <code>NSLog()</code> 的内容。即使是最新的 iOS 设备，<code>NSLog()</code> 输出调试信息所花的时间也是无法忽略的。所以在产品环境中推荐尽可能少的使用 <code>NSLog()</code>。</p>

<blockquote><p>Calling <code>NSLog</code> makes a new calendar for each line logged. Avoid calling <code>NSLog</code> excessively.</p></blockquote>

<p><a href="https://developer.apple.com/videos/wwdc/2012/?id=235">Source</a></p>

<p>下面是通常会用到的宏定义，它会根据 debug/production 来选择执行 <code>NSLog()</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="cp">#ifdef DEBUG</span>
</span><span class='line'><span class="c1">// Only log when attached to the debugger</span>
</span><span class='line'><span class="cp">#    define DLog(...) NSLog(__VA_ARGS__)</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'><span class="cp">#    define DLog(...) </span><span class="cm">/* */</span><span class="cp"></span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'><span class="c1">// Always log, even in production</span>
</span><span class='line'><span class="cp">#define ALog(...) NSLog(__VA_ARGS__)</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="http://iphoneincubator.com/blog/debugging/the-evolution-of-a-replacement-for-nslog">Source</a></p>

<h3>NSString</h3>

<h5>+ (instancetype)stringWithFormat:(NSString *)format,, &hellip;</h5>

<p>创建 <code>NSString</code> 不是特别昂贵，但是当在紧凑循环（比如作为字典的键值）中使用时， <code>+[NSString stringWithFormat:]</code> 的性能可以通过使用类似 <code>asprintf</code> 的 C 函数显著提高。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">firstName</span> <span class="o">=</span> <span class="s">@&quot;Daniel&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">lastName</span> <span class="o">=</span> <span class="s">@&quot;Amitay&quot;</span><span class="p">;</span>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
</span><span class='line'><span class="n">asprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;Full name: %s %s&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">firstName</span> <span class="n">UTF8String</span><span class="p">],</span> <span class="p">[</span><span class="n">lastName</span> <span class="n">UTF8String</span><span class="p">]);</span>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">fullName</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithCString:</span><span class="n">buffer</span> <span class="nl">encoding:</span><span class="n">NSUTF8StringEncoding</span><span class="p">];</span>
</span><span class='line'><span class="n">free</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h5>&ndash; (instancetype)initWithFormat:(NSString *)format, &hellip;</h5>

<p>参考 <a href="#-instancetypestringwithformatnsstring-format-"><code>+[NSString stringWithFormat:]</code></a></p>

<h1>UIKit</h1>

<ul>
<li><a href="#uiimage">UIImage</a></li>
<li><a href="#uiview">UIView</a></li>
</ul>


<hr />

<h3>UIImage</h3>

<h5>+ (UIImage <em>)imageNamed:(NSString </em>)fileName</h5>

<p>如果 boundle 中得某个图片只显示一次，推荐使用 <code>+ (UIImage *)imageWithContentsOfFile:(NSString *)path</code>，系统就不会缓存该图片。参考 Apple 的文档：</p>

<blockquote><p>If you have an image file that will only be displayed once and wish to ensure that it does not get added to the system’s cache, you should instead create your image using imageWithContentsOfFile:. This will keep your single-use image out of the system image cache, potentially improving the memory use characteristics of your app.</p></blockquote>

<p><a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIImage_Class/Reference/Reference.html#//apple_ref/occ/clm/UIImage/imageNamed:">Source</a></p>

<h3>UIView</h3>

<h5>@property(nonatomic) BOOL clearsContextBeforeDrawing</h5>

<p>将 <code>UIView</code> 的属性 <code>clearsContextBeforeDrawing</code> 设置为 <code>NO</code> 在多数情况下可以提高绘制性能，尤其是在你自己用绘制代码实现了一个定制 view 的时候。</p>

<blockquote><p>If you set the value of this property to NO, you are responsible for ensuring the contents of the view are drawn properly in your drawRect: method. If your drawing code is already heavily optimized, setting this property is NO can improve performance, especially during scrolling when only a portion of the view might need to be redrawn.</p></blockquote>

<p><a href="https://developer.apple.com/library/ios/documentation/uikit/reference/uiview_class/uiview/uiview.html#//apple_ref/occ/instp/UIView/clearsContextBeforeDrawing">Source</a></p>

<blockquote><p>By default, UIKit clears a view’s current context buffer prior to calling its drawRect: method to update that same area. If you are responding to scrolling events in your view, clearing this region repeatedly during scrolling updates can be expensive. To disable the behavior, you can change the value in the clearsContextBeforeDrawing property to NO.</p></blockquote>

<p><a href="https://developer.apple.com/library/ios/documentation/2ddrawing/conceptual/drawingprintingios/DrawingTips/DrawingTips.html">Source</a></p>

<h5>@property(nonatomic) CGRect frame</h5>

<p>当设置一个 <code>UIView</code> 的 frame 属性时，应该保证坐标值和像素位置对齐，否则将会触发反锯齿降低性能，也有可能引起图形界面的边界模糊（译者注：尤其是涉及到绘制文字时将会引起文字模糊不清，非 retina 设备特别明显）。一种简单直接的办法就是使用 <code>CGRectIntegral()</code> 自动将 <code>CGRect</code> 的值四舍五入到整数。对于像素密度大于1的设备，可以将坐标值近似为 <code>1.0f / screen.scale</code> 整数倍。</p>

<h1>QuartzCore</h1>

<ul>
<li><a href="#calayer">CALayer</a></li>
</ul>


<hr />

<h3>CALayer</h3>

<h5>@property BOOL allowsGroupOpacity</h5>

<p>在 iOS7 中，这个属性表示 layer 的 sublayer 是否继承父 layer 的透明度，主要用途是当在动画中改变一个 layer 的透明度时（会引起子 view 的透明度显示出来）。但是如果你不需要这种绘制类型，可以关闭这个属性来提高性能。</p>

<blockquote><p>When true, and the layer&rsquo;s opacity property is less than one, the layer is allowed to composite itself as a group separate from its parent. This gives the correct results when the layer contains multiple opaque components, but may reduce performance.</p>

<p>The default value of the property is read from the boolean UIViewGroupOpacity property in the main bundle&rsquo;s Info.plist. If no value is found in the Info.plist the default value is YES for applications linked against the iOS 7 SDK or later and NO for applications linked against an earlier SDK.</p></blockquote>

<p>上述引用来源已不存在，可以参考 <code>CALayer.h</code>。</p>

<blockquote><p>(Default on iOS 7 and later) Inherit the opacity of the superlayer. This option allows for more sophisticated rendering in the simulator but can have a noticeable impact on performance.</p></blockquote>

<p><a href="https://developer.apple.com/library/ios/documentation/general/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW6">Source</a></p>

<h5>@property BOOL drawsAsynchronously</h5>

<p><code>drawsAsynchronously</code> 属性会导致 layer 的 <code>CGContext</code> 延迟到后台线程绘制。这个属性对于频繁绘制的 leyer 有很大的好处。</p>

<blockquote><p>When this property is set to YES, the graphics context used to draw the layer’s contents queues drawing commands and executes them on a background thread rather than executing them synchronously. Performing these commands asynchronously can improve performance in some apps. However, you should always measure the actual performance benefits before enabling this capability.</p></blockquote>

<p><a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CALayer_class/Introduction/Introduction.html#//apple_ref/occ/instp/CALayer/drawsAsynchronously">Source</a></p>

<blockquote><p>Any drawing that you do in your delegate’s drawLayer:inContext: method or your view’s drawRect: method normally occurs synchronously on your app’s main thread. In some situations, though, drawing your content synchronously might not offer the best performance. If you notice that your animations are not performing well, you might try enabling the drawsAsynchronously property on your layer to move those operations to a background thread. If you do so, make sure your drawing code is thread safe.</p></blockquote>

<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/ImprovingAnimationPerformance/ImprovingAnimationPerformance.html">Source</a></p>

<h5>@property CGPathRef shadowPath</h5>

<p>如果要操作 <code>CALayer</code> 的阴影属性，推荐设置 layer 的 <code>shadowPath</code> 属性，系统将会缓存阴影减少不必要的重绘。但当改变 layer 的 bounds 时，一定要重设 <code>shadowPath</code>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">CALayer</span> <span class="o">*</span><span class="n">layer</span> <span class="o">=</span> <span class="n">view</span><span class="p">.</span><span class="n">layer</span><span class="p">;</span>
</span><span class='line'><span class="n">layer</span><span class="p">.</span><span class="n">shadowOpacity</span> <span class="o">=</span> <span class="mf">0.5f</span><span class="p">;</span>
</span><span class='line'><span class="n">layer</span><span class="p">.</span><span class="n">shadowRadius</span> <span class="o">=</span> <span class="mf">10.0f</span><span class="p">;</span>
</span><span class='line'><span class="n">layer</span><span class="p">.</span><span class="n">shadowOffset</span> <span class="o">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">10.0f</span><span class="p">);</span>
</span><span class='line'><span class="n">UIBezierPath</span> <span class="o">*</span><span class="n">bezierPath</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIBezierPath</span> <span class="nl">bezierPathWithRect:</span><span class="n">layer</span><span class="p">.</span><span class="n">bounds</span><span class="p">];</span>
</span><span class='line'><span class="n">layer</span><span class="p">.</span><span class="n">shadowPath</span> <span class="o">=</span> <span class="n">bezierPath</span><span class="p">.</span><span class="n">CGPath</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>Letting Core Animation determine the shape of a shadow can be expensive and impact your app’s performance. Rather than letting Core Animation determine the shape of the shadow, specify the shadow shape explicitly using the shadowPath property of CALayer. When you specify a path object for this property, Core Animation uses that shape to draw and cache the shadow effect. For layers whose shape never changes or rarely changes, this greatly improves performance by reducing the amount of rendering done by Core Animation.</p></blockquote>

<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/ImprovingAnimationPerformance/ImprovingAnimationPerformance.html">Source</a></p>

<h5>@property BOOL shouldRasterize</h5>

<p>如果 layer 只需要绘制依此，那么可以设置 <code>CALayer</code> 的属性 <code>shouldRasterize</code> 为 <code>YES</code>。但是如果该 layer 让然会被移动、缩放或者变形，那么将 <code>shouldRasterize</code> 设置为 <code>YES</code> 会损伤绘制性能，因为系统每次绘制完后会尝试再次重绘。</p>

<blockquote><p>When the value of this property is YES, the layer is rendered as a bitmap in its local coordinate space and then composited to the destination with any other content. Shadow effects and any filters in the filters property are rasterized and included in the bitmap.</p></blockquote>

<p><a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Reference/CALayer_class/Introduction/Introduction.html#//apple_ref/occ/instp/CALayer/shouldRasterize">Source</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/03/09/lets-build-nsobject/">动手创建 NSObject</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-03-09T00:16:54+08:00" pubdate data-updated="true">Mar 9<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/03/09/lets-build-nsobject/#disqus_thread"
             data-disqus-identifier="http://liyong03.github.io/blog/2014/03/09/lets-build-nsobject/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>本文译自<a href="https://www.mikeash.com/pyblog/friday-qa-2013-01-25-lets-build-nsobject.html">这里</a>，转载请注明！</p>

<p>在 Cocoa 编程时创建和使用的（几乎）所有类都是以 NSObject 为根基，但它背后都做了什么、是怎么做的呢？今天，我将从零开始创建 NSObject。</p>

<h2>根类(root class)的组成</h2>

<p>准确地说，根类到底做了什么？以 Objective-C 自身的术语描述，有一个准确的要求：根类的第一个实例变量必须是 isa，它指向一个实例(object)的类(class)，在分发消息的时候，它被用来准确找出该实例的类。从严格的编程语言观点来看，这是根类必须要做的。</p>

<p>当然根类只提供这些是不够的，NSObject 提供了更多的。它提供的功能可以分为一下三类：</p>

<ol>
<li><strong>内存管理</strong>：标准的内存管理方法如 <em>retain</em> 和 <em>release</em> 都是在 NSObject 中实现的，<em>alloc</em> 方法也是如此。</li>
<li><strong>内省</strong>：NSObject 提供了很多 Objective-C 运行时方法的包装，例如 <em>class</em>、<em>respondsToSelector:</em> 和 <em>isKindOfClass:</em>。</li>
<li><strong>内置实用方法</strong>：有很多每一个实例都需要实现的方法，例如 <em>isEqual:</em> 和 <em>description</em>。为了保证每一个实例都有这些方法，NSObject 提供了这些方法的默认实现。</li>
</ol>


<h2>代码</h2>

<p>我接下来将要在 MAObject 中实现 NSObject 的功能，源代码在 Github: <a href="https://github.com/mikeash/MAObject">https://github.com/mikeash/MAObject</a></p>

<p>这个代码没有使用 ARC，虽然 ARC 是个好东西，而且应该尽可能使用它，不过在实现根类的时候使用就不太合适，因为根类需要实现内存管理，如果使用 ARC 就把内存管理交给编译器了！</p>

<h3>实例变量</h3>

<p>MAObject 有两个实例变量，第一个是 isa 指针，第二个是实例的引用计数<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">MAObject</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Class</span> <span class="n">isa</span><span class="p">;</span>
</span><span class='line'>    <span class="k">volatile</span> <span class="n">int32_t</span> <span class="n">retainCount</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们将使用 OSAtomic.h 中的方法管理引用计数保证线程安全，这就是为什么这里没有用 NSUInteger 或者类似的声明，而是用了个看起来不寻常的方式。</p>

<p>实际上 NSObject 是把引用计数保存在外面。有一个全局的表（table），标中是实例地址和引用计数映射。这样可以节省内存，因为不在表中的实例的引用计数默认就是1。尽管有这些好处，但是这样实现起来有点复杂并且性能有些慢，所以在这里我就不实现这种方法了。</p>

<h3>内存管理</h3>

<p>MSObject 需要做的第一件事情就是创建实例，主要在 +alloc 中实现完成。（这里我略过了已经弃用的 +allocWithZone: 方法，这个方法实际上会忽略参数，完成 +alloc 同样的工作。）</p>

<p>子类一般很少会重写 +alloc，而是依赖根类来分配内存。这就意味着 MAObject 不仅要为自己分配内存，还要为子类分配内存，完成这个就要利用<strong>类方法中的 self 的值实际上就是消息将会被分发到的类</strong>这一优势。例如代码为 <strong>[SomeSubClass alloc]</strong>，那么 self 就是指向 SomeSubClass。这个类将会被用来使用运行时方法确定需要的内存大小和正确设置 isa 。同时引用计数的值也会被设为1，与创建一个实例的行为相符：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">alloc</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">MAObject</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">class_getInstanceSize</span><span class="p">(</span><span class="n">self</span><span class="p">));</span>
</span><span class='line'>    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">isa</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'>    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">retainCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>retain</strong> 方法很简单，就是使用 <strong>OSAtomicIncrement32</strong> 方法将引用计数加1，然后返回 self：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">retain</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">OSAtomicIncrement32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retainCount</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>release</strong> 方法干的事情多一点，首先将引用计数减1，如果引用计数降为0了，那么实例需要被销毁，所以要调用 <strong>dealloc</strong>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">oneway</span> <span class="kt">void</span><span class="p">)</span><span class="nf">release</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">uint32_t</span> <span class="n">newCount</span> <span class="o">=</span> <span class="n">OSAtomicDecrement32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retainCount</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">newCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="p">[</span><span class="n">self</span> <span class="n">dealloc</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>autorelease</strong> 的实现实际上调用 <strong>NSAutoreleasePool</strong> 将 self 加入当前的 autorelease pool 。Autorelease pool 现在时运行时的一部分，所以这样做不是很直接，但是 autorelease pool 的 API 是私有的，所以这样实现也是目前最好的办法了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">autorelease</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">NSAutoreleasePool</span> <span class="nl">addObject:</span> <span class="n">self</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>retainCount</strong> 方法简单返回引用计数值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">retainCount</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">retainCount</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后是 <strong>dealloc</strong> 方法，通常类的 dealloc 方法清除所有的实例变量，然后调用父类的 dealloc 。所以根类实际上需要释放占用的内存。这里通过调用 free 来完成：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">free</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>还有一些辅助的方法。NSObject 为了一致性提供了一个什么也没做的 init 方法，所以子类通常会调用 [super init]：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>还有一个 new 方法，它只是包装了一下 alloc 和 init ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">new</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[[</span><span class="n">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>还有个空的 finalize 方法。NSObject 把它作为垃圾回收的一部分实现了。不过 MAObject 开始就不支持垃圾回收，不过我在这里加上它只是因为 NSObject 有它：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">finalize</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>内省</h3>

<p>很多内省的方式只是运行时方法的包装，因为这没太大意思，所以我会简单介绍一下运行时方法背后的工作原理。</p>

<p>最简单的内省方法就是 <strong>class</strong> ，它只是返回 isa ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nf">class</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">isa</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从技术上来讲，这样的实现在 isa 是一个标记指针(tagged pointers)<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> 时就会发生错误，更合理的实现应该是调用 object_getClass 方法，它在标记指针时也可以正常工作。</p>

<p>实例方法 superclass 和使用类来调用 superclass 的行为一样，我们也是这么实现的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nf">superclass</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[[</span><span class="n">self</span> <span class="n">class</span><span class="p">]</span> <span class="n">superclass</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>有很多类方法也是内省的一部分，+class 直接返回 self ，实际上它时一个类实例(class object)。这里有些奇怪，但实际上 NSObject 就是这么工作的。[object class] 返回的是实例的类，[MyClass class] 返回的指针指向 MyClass 本身，看起来不一致，实际上 MyClass 也有一个类，他就是 MyClass 的元类(meta class) 。下面是实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nf">class</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>+superclass 方法顾名思义，它是通过调用 class_getSuperclass 实现的，该方法会解析运行时的类结构来找出指向父类的指针：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nf">superclass</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">class_getSuperclass</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>还有一些方法用来查询某个实例的类是否与指定的类相匹配，最简单的一个就是 isMemberOfClass: ，该方法进行严格匹配，会忽略子类，实现如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isMemberOfClass:</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nv">aClass</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">isa</span> <span class="o">==</span> <span class="n">aClass</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>isKindOfClass: 方法会检查子类，所以 [subclassInstance isKindOfClass: [Superclass class]] 会返回 YES 。该方法的返回值与 +isSubclassOfClass: 的返回值完全一样，我们也是通过调用它来实现的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isKindOfClass:</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nv">aClass</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">isa</span> <span class="nl">isSubclassOfClass:</span> <span class="n">aClass</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>+isSubclassOfClass: 方法有点意思，它会从 self 开始向上递归，在每一层比较目标类。如果找到相匹配的，就返回 YES ，如果一直找到类继承机构的顶层也没有匹配的，就返回 NO ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isSubclassOfClass:</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nv">aClass</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(</span><span class="n">Class</span> <span class="n">candidate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span> <span class="n">candidate</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">;</span> <span class="n">candidate</span> <span class="o">=</span> <span class="p">[</span><span class="n">candidate</span> <span class="n">superclass</span><span class="p">])</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">candidate</span> <span class="o">==</span> <span class="n">aClass</span><span class="p">)</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>你可能已经注意到了这里不是很高效，如果你对一个处在很深的继承关系中的类调用该方法，它在返回 NO 之前将会进行很多次循环。因此 isKindOfClass: 会比通常的消息发送慢，在某种情况下会是性能瓶颈，这也是需要避免使用这类方法的原因之一。</p>

<p><strong>respondsToSelector:</strong> 方法只是调用运行时方法 <strong>class_respondsToSelector</strong> ，该方法在类的方法表中依此查找看是否有匹配项：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">respondsToSelector:</span> <span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">class_respondsToSelector</span><span class="p">(</span><span class="n">isa</span><span class="p">,</span> <span class="n">aSelector</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>还有另外一个类方法 <strong>instancesRespondToSelector:</strong> 和上面的方法几乎一样，不过唯一的区别是它的实现传入的是 self 而不是 isa ，在上下文环境中 self 应该是元类(meta class)：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">instancesRespondToSelector:</span> <span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">class_respondsToSelector</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">aSelector</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>与此类似，也有两个 <strong>conformsToProtocol:</strong> 方法，一个是实例方法，另一个是类方法。他们也都是对运行时方法的包装，在这里是去遍历所有类遵循的协议(protocol)表，坚持给定的协议是否在其中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">conformsToProtocol:</span> <span class="p">(</span><span class="n">Protocol</span> <span class="o">*</span><span class="p">)</span><span class="nv">aProtocol</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">class_conformsToProtocol</span><span class="p">(</span><span class="n">isa</span><span class="p">,</span> <span class="n">aProtocol</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">conformsToProtocol:</span> <span class="p">(</span><span class="n">Protocol</span> <span class="o">*</span><span class="p">)</span><span class="nv">protocol</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">class_conformsToProtocol</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">protocol</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>下一个方法是 <strong>methodForSelector:</strong> ，类方法中类型的方法是 <strong>instanceMethodForSelector:</strong> 。他们俩都会调用运行时方法 <strong>class_getMethodImplementation</strong> ，该方法会查找类的函数表，然后返回响应的 IMP ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">IMP</span><span class="p">)</span><span class="nf">methodForSelector:</span> <span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">class_getMethodImplementation</span><span class="p">(</span><span class="n">isa</span><span class="p">,</span> <span class="n">aSelector</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">+</span> <span class="p">(</span><span class="n">IMP</span><span class="p">)</span><span class="nl">instanceMethodForSelector:</span> <span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="n">aSelector</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">class_getMethodImplementation</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">aSelector</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>有趣的一点是 <strong>class_getMethodImplementation</strong> 总是返回一个 IMP ，即使参数是一个不存在的 selector 。当类没有实现某个方法时，它会返回一个特殊的转发 IMP ，这个 IMP 包装好了调用 <strong>forwardInvocation:</strong> 的消息参数。</p>

<p>方法 <strong>methodSignatureForSelector:</strong> 只是对类方法的包装：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSMethodSignature</span> <span class="o">*</span><span class="p">)</span><span class="nf">methodSignatureForSelector:</span> <span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">isa</span> <span class="nl">instanceMethodSignatureForSelector:</span> <span class="n">aSelector</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>而这个类方法也是对运行时方法的包装。它首先获取输入 selector 的 Method 。如果不能得到，那么就表明类没有实现该方法，那么返回 nil 。否则就获取方法类型的 C 字符串表达，并且包装在 <strong>NSMethodSignature</strong> 中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">NSMethodSignature</span> <span class="o">*</span><span class="p">)</span><span class="nf">instanceMethodSignatureForSelector:</span> <span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">Method</span> <span class="n">method</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">aSelector</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">method</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">types</span> <span class="o">=</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">method</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">NSMethodSignature</span> <span class="nl">signatureWithObjCTypes:</span> <span class="n">types</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后是 <strong>performSelector:</strong> 方法，还有两个类似方法用 <strong>withObject:</strong> 去接收参数。他们不是严格意义上的内省方法，但他们都是对底层运行方法的包装。他们只是获取 selector 的 IMP ，强制转换成合适的函数指针类型，然后调用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">performSelector:</span> <span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">IMP</span> <span class="n">imp</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">methodForSelector:</span> <span class="n">aSelector</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">((</span><span class="kt">id</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))</span><span class="n">imp</span><span class="p">)(</span><span class="n">self</span><span class="p">,</span> <span class="n">aSelector</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">performSelector:</span> <span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="nf">withObject:</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">IMP</span> <span class="n">imp</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">methodForSelector:</span> <span class="n">aSelector</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">((</span><span class="kt">id</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">,</span> <span class="kt">id</span><span class="p">))</span><span class="n">imp</span><span class="p">)(</span><span class="n">self</span><span class="p">,</span> <span class="n">aSelector</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">performSelector:</span> <span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="nf">withObject:</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object1</span> <span class="nf">withObject:</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object2</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">IMP</span> <span class="n">imp</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">methodForSelector:</span> <span class="n">aSelector</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">((</span><span class="kt">id</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">,</span> <span class="kt">id</span><span class="p">,</span> <span class="kt">id</span><span class="p">))</span><span class="n">imp</span><span class="p">)(</span><span class="n">self</span><span class="p">,</span> <span class="n">aSelector</span><span class="p">,</span> <span class="n">object1</span><span class="p">,</span> <span class="n">object2</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>内置实用方法</h3>

<p>MAObject 提供了很多方法的默认实现，我们从 <strong>isEqual:</strong> 和 <strong>hash</strong> 两个方法开始，因为它们都是用实例的指针进行唯一性判断：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isEqual:</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span> <span class="o">==</span> <span class="n">object</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">hash</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>任何子类想要实现更复杂的相等判断就要重写这些方法，但是如果子类想要只有和自身相等的情况下就可以使用这些方法。</p>

<p>另外一个方便的方法是 <strong>description</strong> ，我们也有一个默认实现。这个方法只是生成一个类似 <strong>&lt;MAObject: 0xdeadbeef></strong> 的字符串，包含了实例的类和指针：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">description</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span> <span class="s">@&quot;&lt;%@: %p&gt;&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">self</span> <span class="n">class</span><span class="p">],</span> <span class="n">self</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>类方法 <strong>description</strong> 只需要返回类的名字即可，所以调用运行时方法获取类名然后返回即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">description</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithUTF8String:</span> <span class="n">class_getName</span><span class="p">(</span><span class="n">self</span><span class="p">)];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>doesNotRecognizeSelector:</strong> 是一个知道的人比较少的实用方法。它会通过抛异常来让类看起来不会响应某些方法，这在我们创建一些子类必须重写的方法时很有用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">subclassesMustOverride</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// pretend we don&#39;t actually implement this here</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">doesNotRecognizeSelector:</span> <span class="n">_cmd</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码很简单，唯一有些技巧的地方就是正确给出方法的名称，我们想为实例输出类似 <strong>&ndash;[Class method]</strong> 的东西，同时类方法前面需要显示 <strong>+</strong> ，类似 <strong>+[Class classMethod]</strong> 。为了分辨是哪种情况，我们就需要检查 isa 是不是元类，如果是元类，那么 self 就是类，需要显示 <strong>+</strong> 。否则 self 就是实例，需要用 <strong>&ndash;</strong> 。代码其他部分就是用来抛异常：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">doesNotRecognizeSelector:</span> <span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="o">*</span><span class="n">methodTypeString</span> <span class="o">=</span> <span class="n">class_isMetaClass</span><span class="p">(</span><span class="n">isa</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;+&quot;</span> <span class="o">:</span> <span class="s">&quot;-&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">NSException</span> <span class="nl">raise:</span> <span class="n">NSInvalidArgumentException</span> <span class="nl">format:</span> <span class="s">@&quot;%s[%@ %@]: unrecognized selector sent to instance %p&quot;</span><span class="p">,</span> <span class="n">methodTypeString</span><span class="p">,</span> <span class="p">[[</span><span class="n">self</span> <span class="n">class</span><span class="p">]</span> <span class="n">description</span><span class="p">],</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">aSelector</span><span class="p">),</span> <span class="n">self</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后，还有很多显而易见的方法（比如 self 方法），很多让子类安全调用 <strong>super</strong> 的方法（类似空的 <strong>+initialize</strong> 方法），很多重写点（例如 <strong>copy</strong> 就会抛异常）。这些都没太多意思，但都包括在了 MAObject 中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">self</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isProxy</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">load</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">initialize</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">copy</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">doesNotRecognizeSelector:</span> <span class="n">_cmd</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">mutableCopy</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">doesNotRecognizeSelector:</span> <span class="n">_cmd</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">forwardingTargetForSelector:</span> <span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">forwardInvocation:</span> <span class="p">(</span><span class="n">NSInvocation</span> <span class="o">*</span><span class="p">)</span><span class="nv">anInvocation</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">doesNotRecognizeSelector:</span> <span class="p">[</span><span class="n">anInvocation</span> <span class="n">selector</span><span class="p">]];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">resolveClassMethod:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">sel</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">resolveInstanceMethod:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">sel</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>总结</h2>

<p>NSObject 其实就是一大堆不同函数的组合，没什么奇怪之处。它的主要功能就是分配和管理内存，你可据此创建实例。同时它也提供了一堆每个方法都应该支持的有用的重写点，也包装了很多有用的运行时 API 。</p>

<p>这里我忽略了 NSObject 的一个块内容：key-value coding ，这块复杂到我需要另写<a href="https://www.mikeash.com/pyblog/friday-qa-2013-02-08-lets-build-key-value-coding.html">一篇文章</a>了。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>NSObject 的实现有些不同，具体可以参考实现源码：<a href="http://opensource.apple.com/source/objc4/objc4-532.2/runtime/NSObject.mm">http://opensource.apple.com/source/objc4/objc4-532.2/runtime/NSObject.mm</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>详情请参考<a href="http://en.wikipedia.org/wiki/Tagged_pointer">http://en.wikipedia.org/wiki/Tagged_pointer</a>和<a href="https://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html">https://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/17/ios-frp/">iOS 的 ReactiveCocoa 函数式响应编程</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-17T23:33:11+08:00" pubdate data-updated="true">Feb 17<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/02/17/ios-frp/#disqus_thread"
             data-disqus-identifier="http://liyong03.github.io/blog/2014/02/17/ios-frp/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>本文翻译自<a href="http://www.teehanlax.com/blog/reactivecocoa/">这里</a>，其中一些语法由于 ReactiveCocoa 的演进我做了修改。</p>

<p>Objective-C 是一种基于C语言、但又常常深陷于C的过时编程方式的编程语言。随着计算机计算能力的提升，编程语言设计也与时俱进，但是Objective-C有时好像留在了过去。</p>

<p>Objective-C和C都属于计算机顺序执行软件指令的<a href="http://en.wikipedia.org/wiki/Imperative_programming">指令式编程语言</a>，软件的行为也出自执行这些指令。如果开发者写出来正确顺序的指令，那么软件的行为也满足程序的期望。</p>

<p>但是写出来的代码总是有缺陷，我们需要使用或是手动或是自动的测试去减少这些问题，但是如果能抽象单独的指令，而把注意力放在期望行为上面。这就是<a href="http://en.wikipedia.org/wiki/Declarative_programming">声明式编程</a>的由来。</p>

<p>指令范式强制让开发者写程序去完成一些任务，而声明范式解放开发者去描述任务是什么。</p>

<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>是一种让 Objective-C 少一些指令式属性，多一些响应式属性。它将<em>怎样</em>抽象成<em>什么</em>。</p>

<p>下面我们用几个例子来展示 Objective-C 中的声明式编程是什么样的。</p>

<p>ReactiveCocoa 的核心是<em>信号 (signal)</em> ，信号代表了不同时间发生的事件流。<em>订阅 (subscribing)</em> 信号允许开发者访问这些事件。下面开看一个基础的例子。</p>

<p>iOS App 中得输入框(Text Field)在输入文字发生改变时会产生的事件会生成信号。ReactiveCocoa 的 UITextField 分类(Category)有一个方法：<em>rac_textSignal</em>，我们可以这样订阅这个事件：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">usernameField</span><span class="p">.</span><span class="n">rac_textSignal</span> <span class="nl">subscribeNext:</span><span class="o">^</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Text field has been updated: %@&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码中，我们声明输入框的文字变化时，将它的新值打印出来。无论何时输入框的信号发送了一个事件，这块代码都将被以新的文本内容为参数调用。</p>

<p><img src="/images/subscription.png" alt="subscription" /></p>

<p>信号很牛逼的地方在于它可以组合使用。我们可以过滤 <em>rac_textSignal</em> 返回的信号，以保证字符串的长度大于3才能登陆：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[[</span><span class="n">self</span><span class="p">.</span><span class="n">textField</span><span class="p">.</span><span class="n">rac_textSignal</span> <span class="nl">filter:</span><span class="o">^</span><span class="kt">BOOL</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">[</span><span class="n">value</span> <span class="n">length</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'><span class="p">}]</span> <span class="nl">subscribeNext:</span><span class="o">^</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Text field has been updated: %@&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>Filter 方法返回一个新的信号。当第一个信号发射了一个事件，这个事件的值将被传递到 <em>filter</em> 代码块。如果这块代发返回 YES，那么新的信号会发射一个事件。后代码订阅的就是这个 filter 返回的信号。</p>

<p><img src="/images/filter.png" alt="filter" /></p>

<p>我们来做一些更复杂的吧。我们将两个输入框的两个信号<em>联合 (combine)</em> 起来，将他们的值<em>降 (reduce)</em> 为一个布尔值，然后和另一个按钮的 <em>enable</em> 属性<em>绑定 (bind)</em> 在一起。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[[</span><span class="n">RACSignal</span> <span class="nl">combineLatest:</span><span class="err">@</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">firstNameField</span><span class="p">.</span><span class="n">rac_textSignal</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">lastNameField</span><span class="p">.</span><span class="n">rac_textSignal</span><span class="p">]</span>
</span><span class='line'>  <span class="nl">reduce:</span><span class="o">^</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">firstName</span><span class="p">,</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">lastName</span><span class="p">){</span>
</span><span class='line'>      <span class="k">return</span> <span class="err">@</span><span class="p">(</span><span class="n">firstName</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">lastName</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}]</span> <span class="nl">setKeyPath:</span><span class="s">@&quot;enabled&quot;</span> <span class="nl">onObject:</span><span class="n">self</span><span class="p">.</span><span class="n">button</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>按钮的 enable 状态总是由两个输入框的最新的信号所派生。这代表了函数响应式编程众多核心理念中的一个：派生状态(deriving state)。</p>

<p><img src="/images/combine.png" alt="combine" /></p>

<p>在上述所有例子中，我们都在 <strong>viewDidLoad</strong> 中有所声明，在应用运行时这些陈述都保持为真。这里我们没有实现任何代理方法(delegate methods)或者保存任何状态。所有行为都是显式声明而不是隐式的推断。</p>

<p>函数响应式编程非常复杂，而学习 ReactiveCocoa 的丰富细节也需要时间。但是学习这些也会带来具有可预测的、良好定义行为的稳定程序。</p>

<p>软件开发的历史告诉我们软件开发的趋势是朝着更高级别的抽象迈进，诚如我们现在再也不会和穿孔卡片或者汇编语言打交道一样。我相信函数响应式编程是抽象的另一个更高层次，借此程序员可以更快地开发出更好地软件。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/01/11/my-2013/">我的 2013</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-01-11T17:19:51+08:00" pubdate data-updated="true">Jan 11<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/01/11/my-2013/#disqus_thread"
             data-disqus-identifier="http://liyong03.github.io/blog/2014/01/11/my-2013/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>2013年飞逝而过！对我来说，这一年真如坐过山车，起起伏伏，<strong>人生如梦</strong>的感慨对我的2013来说最是贴切。这篇日志是对我的2013年的总结，也是对这神奇一年的备忘！</p>

<h5>工作</h5>

<p>2013年起伏的事情都发生在工作中。2012年成功发布 iPhone Flickr<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 后，13年前半段开始了新iPad项目，同时也维护已发布的App。下半年由于公司策略问题，将所有的移动项目拿回总部，我的项目也被拿了回去。我也被换到了新的项目。新的项目是Yahoo!主页推荐系统的后台，这对我来说是个新的挑战，从前端到后端，也捡起来了丢下好久的C++。</p>

<p>工作中有个大的插曲，2013年前几个月一直在忙内部 Transfer，我全家做好了搬到湾区开始新生活的准备。不过由于临走前发生了一起让我躺枪、也让我震惊的事情，我的 Transfer 最终没有成行。这件事情让我重新思考了待人待事的态度方法，期间公司的做法和决定也让我下定决心离开Yahoo!.</p>

<p>2013年后半段开始计划换工作，从准备到结束花了将近3个月，最终皇天不负有心人，我对结果非常满意。</p>

<h5>技术</h5>

<p>2013年我的技术积累还主要在iOS开发上面。项目重构重写让我重新审视了自己以前的设计和编码，发现弥补了很多不足。这一年我更加注重程序的设计和架构，我认为好的程序不应该能够工作就好了，还要有美感，要能重用、方便扩展。这一年我也更加关注后端的技术，从大规模服务器到大数据处理。好的软件工程师应该了解方方面面，并且有一两个精通的方向。</p>

<h5>生活</h5>

<p>2013年的生活被工作影响比较大。前面提到的内部Transfer没有成行，对我和我的家庭有很大影响，我们花了1个多月才让生活恢复正常。</p>

<p>一年内我和老婆以及朋友完成了两趟比较长的自驾游。</p>

<br>第一条线路是 北京->承德->塞罕坝->塔里湖->锡林郭勒->草原天路->张家口->北京。这一趟花了7天，把北京北边主要景区都走过了。唯一遗憾的是由于时间是秋天，所以草原的美景不如夏季那么好，不过也是别有一番风情。


<br>第二条线路是 旧金山->Half moon bay->Moterey->Camel->洛杉矶->圣地亚哥->洛杉矶->旧金山，这一趟花了14天。和老婆一起在美国度过了圣诞节和新年，一路风景迷人、气候宜人。


<p>对了，2013年健身的决心无比坚定，已经减肥接近8Kg！</p>

<h5>2014希望</h5>

<p>全家健康，一切顺顺利利，自己更加强大。</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>https://itunes.apple.com/hk/app/flickr/id328407587?mt=8<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/01/11/hello-from-octopress/">Hello From Octopress</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-01-11T13:21:30+08:00" pubdate data-updated="true">Jan 11<span>th</span>, 2014</time>
        
           | <a href="/blog/2014/01/11/hello-from-octopress/#disqus_thread"
             data-disqus-identifier="http://liyong03.github.io/blog/2014/01/11/hello-from-octopress/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>2014年决定在这里开始写blog，主要发布一些技术观察，技术总结和个人随想。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/04/27/ios-performance/">iOS App 性能备忘</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/03/09/lets-build-nsobject/">动手创建 NSObject</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/02/17/ios-frp/">iOS 的 ReactiveCocoa 函数式响应编程</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/01/11/my-2013/">我的 2013</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/01/11/hello-from-octopress/">Hello From Octopress</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Yong Li -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'liyong03';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
